
=========================================================================
构造方法和普通方法在定义上有区别：
首先构造方法没有返回值，并且名字要与类名保持一致。
构造方法可以用来完成,成员属性的初始化工作。
每个类至少有一个构造方法，如果没有，系统会提供一个默认的无参构造.
而普通方法，就是类的行为举止。表明该做什么事情..等等。
=========================================================================
String:
=========================================================================
    直接赋值（=“hello”），只会开辟一块堆内存空间，并且该字符串对象可以保存在对象池中以供下次使用（每个赋值内容一样的数组，指向内存地址相同，减少内存重复开辟，节约内存）
    构造方法（new String("hello")）,会开辟两块堆内存空间， 其中一块堆内存空间将成为垃圾空间，并且不会保存在对象池中（可以使用.intern()方式手工入池（（new String("hello")。intern（）），除了这一缺点以外，实际上也会对字符串共享产生问题
所以直接赋值比构造方法好
-------------------------------------------------------------------------
    “==”	:进行的是数值比较，比较的是两个字符串内存地址数值
    “equal()"：	可以进行字符串内容的比较
最好字符串放在前面，如："hello".equal(input),防止没有输入内容造成错误

    字符串不适合频繁修改，如String x="hello "; x+="word";就产生三个内存空间“hello "、"word"、"hello word"，其中前两个为垃圾内存空间
-------------------------------------------------------------------------
总结：
    1.字符串的使用就采用直接赋值的模式完成。
    2.字符串的比较就使用equals（）方法实现
    3.字符串没事别改变太多
-------------------------------------------------------------------------
字符串与字符数组转换：
public String(char[] value)	将字节数组中的所有内容变为字符串
public String(char[] value, int offset, int count)	将字节数组中的部分内容变为字符串 offset：开始位置 count：个数
public char charAt(int index)	指定索引位置的字符，索引从0开始
public char[] toCharArray()	将字符串变为字符数组
-------------------------------------------------------------------------
字符串与字节 转换：
public String(byte[] value)	将字符数组中的所有内容变为字符串
public String(byte[] value, int offset, int length)	将字符数组中的部分内容变为字符串 offset：开始位置 count：个数
public byte[] getBytes()	将字符串以字节数组的形式返回
-------------------------------------------------------------------------
字符串比较：
public boolean equal(String anObject)	区分大小写比较
public boolean equalIgnoreCase(String anotherString)	不区分大小写比较
public int compareTo(String anotherString)	比较两个字符串大小关系，相等返回0，大于返回内容大于0，小于返回内容小于0，能比较中文
-------------------------------------------------------------------------
字符串查找：
public boolean contains(String s)	判断一个子字符串是否存在
public int indexOf(String str)	从头开始查找指定字符串的位置，查到了返回位置的开始索引，如果查不到返回-1
public int indexOf(String str, int fromIndex)	从指定位置开始查找子字符串的位置
public int lastIndexOf(String str)	由后向前查找子字符串的位置
public int lastIndexOf(String str, int fromIndex)	从指定位置开始由后向前查找子字符串的位置
public boolean startsWith(String prefix)	从头开始判断是否以指定的字符串开头
public boolean startsWith(String prefix, int toffset)	从指定位置开始判断是否以指定的字符串开头
public boolean endsWith(String suffix)	判断是否以指定的子字符串结尾

最方便的是contains（），直接返回boolean类型。该判断形势是从jdk1.5开始的。
-------------------------------------------------------------------------
字符串替换：
public String replaceAll(String regex, String replacement)	替换所有指定内容 regex：要替换的字符串，replacement：替换为的字符串
public String replaceFirst(String regex, String replacement)	替换首个内容
-------------------------------------------------------------------------
字符串拆分：
public String[] split(String regex)	将字符串全部拆分 regex：以该字符串作为分割符拆分
public String[] split(String regex，int limit)	将字符串部分拆分，该数组长度就是limit极限 limit：拆分为最多的指定个数的 字符串，前面拆，后面就不拆了

如果发现有些内容无法拆分开，就需要使用"\\"转译，如ip地址（.split("\\.");)
-------------------------------------------------------------------------
字符串截取：
public String substring(int beginIndex)	从指定索引截取到结尾
public String substring(int beginIndex,int endIndex)	截取部分内容
-------------------------------------------------------------------------
其他操作：
public String trim()	去掉字符串中左右空格，保留中间空格
public String toUpperCase()	字符串转大写
public String toLowerCase()	字符串转小写
    使用这两个不是字母的不转换
public String intern()	字符串入对象池
public String concat(String str)	字符串连接，等同于“+”
public int length()	取得字符串的长度
public boolean isEmpty()	判断是否为空字符串（但不是null，而是长度为0）没有内容为true

首字母大写在程序开发中使用频率很高
public static String initcap(String str){
    if (str==null&&"".equals(str)){
         return str;
    }
    if (str.length()>1){
         return str.substring(0,1).toUpperCase()+str.substring(1);
    }
    return str.toUpperCase();
}
=========================================================================
this：
=========================================================================
this从实际讲可以做三件事：调用本类属性、调用本类方法（普通、构造）、表示当前对象（相对概念）。

只要在类的方法中访问类的属性，那么属性前一定要加this关键字形式

类中的方法一共有两种：
	普通方法：this.方法名称（参数...）;
	构造方法：this(参数...)。
    虽然调用本类的普通方法前可以不使用this，但是强烈建议追加上this，这样的目的是可以区分方法的定义来源。
构造方法与普通方法最大的区别：使用关键字new实例化类新对象的时候使用一次，而普通方法是在对象实例化完成后（构造方法已经执行过了）可以调用多次。
    在java里面支持类构造方法的互相调用。
this（） 调用本类无参构造

虽然使用this可以实现构造方法的互相调用，但是此时有一下两点要求：
	this（）调用构造方法的语句必须放在构造方法的首行；
	使用this调用构造方法的时候请留有出口；

只要有某一个对象调用了本类中的方法，那么这个this就表示当前执行的对象。
=========================================================================
引用传递：
=========================================================================
引用传递是java的整体核心，如果不懂引用传递，基本上所有的代码都无法进行正常点分析。
-------------------------------------------------------------------------
以后开发过程中，所使用到的类基本都要求由开发者自己来定义。这些里面都使用的引用传递的概念】
=========================================================================
static:
=========================================================================
    在所有定义的方法上以及属性上实际上都可以使用static关键字进行定义。
-------------------------------------------------------------------------
static属性：
    访问static属性都使用类名称，所有的非static的属性必须在产生实例化对象之后才可以使用，而所有static的属性不受实例化对象的限制，也就是说是否有对象与static属性操作无关。
选择：关于static属性与非static属性定义的选择
    在定义类99%的情况下是不会考虑static属性的； 
    如果需要描述共享属性的概念，或者不希望受到实例化对象控制的使用static属性
-------------------------------------------------------------------------
static方法：
    Static定义的属性可以被类名称直接访问，那么同样如果使用static定义的方法也可以直接被类名称进行访问。同样不受到实例化对象的控制。
    现在类中已经存在有static方法和非static方法，那么这个时候对于两者的互相调用就存在有限制；
	所有的static方法不允许调用非static定义的属性或方法；调用使用类.对象
	所有的非static方法允许访问static方法或属性
	原因：因为所有的static方法可以在没有实例化对象的时候访问，而所有的非static操作必须在有实例化对象产生之后才可以操作。
	使用static的属性是影响目的（因为属性都需要封装），但是使用static的方法目的只有一个：某些方法不希望受到类的限制，即：可以在没有实例化对象的时候进行执行。
-------------------------------------------------------------------------
主方法组成：
    如果一个方法定义在主类之中类之中，并且由主方法直接调用，那么该方法的定义语法如下：
    public static 返回值类型 方法名称（参数列表）{}
	public:	表示的是公共的，主方法作为起点必须可以访问；
	static:执行Java程序的时候执行的是一个类名称，所以表示不受实例化对象限制；
	void:主方法是一切的起点；
	main:是一个系统定义好的方法名称；
	String args[]:表示该类执行时所需要的相关参数。
-------------------------------------------------------------------------
static应用：
    Static属性的最大功能是进行共享的操作，所以在这一基础上可以使用static做一个对象产生的计数统计。所有新对象的产生一定要使用构造方法完成，所以可以在构造方法实现统计。
1、static定义的属性和方法并不是你在进行类设计时的首要选择；
2、static的属性和方法不受到一个类的实例化对象限制，可以由类名称直接定义、
=========================================================================
代码块：（不重要）代码中加{}
=========================================================================
    代码块是一个不重要的概念，但是作为结构清楚一下就可以了。所谓的代码块指的是使用了"{}"定义的一段程序代码，而代码块根据其定义的位置以及声明的关键字不同一共可以分为四类：普通代码块、构造块、静态块、同步代码块。
-------------------------------------------------------------------------
普通代码块：（没用） 类中加{}
    普通代码块指的是定义在方法中的代码块。
    如果觉得限制的方法中代码写的过长，但是又需要避免变量重名问题，往往会使用普通代码块，一般人不会用。 
-------------------------------------------------------------------------
构造块：
    构造块指的是定义在类中的代码块
    每一次使用关键字new实例化对象的时候一定调用构造方法，但是有了构造块之后发现构造块会优先于构造方法先执行。
    唯一好处是进行一些简单的逻辑操作，但是又没什么用。
    构造块的使用只是一种补充手段，而这种手段恰恰有没有意义。
-------------------------------------------------------------------------
静态块：类中加static{}
    是使用static关键字定义的代码块。但是如果要想去考虑静态块必须分为两种情况：
	1.是在非主类中定义的静态块；
	2.在主类中定义的静态块。
    静态块优先于构造块执行，而且不管产生多少个实例化对象，静态块也只使用一次。静态块最为主要的作用就是为static属性初始化。
    静态块也可以定义在主类里面，那么此时的静态块将优先于主方法执行，一般而言没有意义。
-------------------------------------------------------------------------
	如果在一些属性使用前做处理就使用构造块或静态块完成。
=========================================================================
内部类的定义及使用：
=========================================================================
    对应内部类的定义使用暂时不作为我们首要的类设计原则
-------------------------------------------------------------------------
内部类的基本概念：
    所谓的内部类指的就是一个类的内部进行其它类结构嵌套的操作语法格式。一层层进行类的嵌套定义。
    虽然内部类破坏了程序的结构从整体上来讲是不好，但是从另外一个方面来讲，内部类也是有优点的，优点在于外部类的私有访问
    1、内部类的访问必须通过外部类的方法才可以完成。如果现在不想通过外部类访问进行调用，想在程序外部调用，那么就必须按照如下的形式进行内部类的实例化对象创建： 
	语法：外部类.内部类 内部类对象=new 外部类().new 内部类(); 
	之所以要先进行外部类对象实例化，主要的问题在于此时的外部类存在有普通的属性，那么这些属性只有开辟实例化对象之后才能够被访问。
    2、如果说现在一个内部类只想被外部类使用，即：不希望直接产生内部类的实例化对象，那么可以使用private定义；
    3、在进行属性访问的时候都需要习惯性的加上this。如果想要在内部类中明确的使用this，那么语法形式：“外部类.this.属性”。这就表示外部类当前对象的属性。
-------------------------------------------------------------------------
static定义内部类：(不会作为第一考虑对象）
    内部类中如果使用了static定义，那么就表示其就是一个外部类的形式，但这个“外部类”的名称就是“外部类.内部类”，同时该内部类只允许访问外部类中的static操作。
    那么如果想要操作这样外部类，就应该使用如下语法：
	实例化对象：外部类.内部类 内部类对象=new 外部类.内部类();
-------------------------------------------------------------------------
在方法中定义内部类：
    理论上内部类可以定义在类中的任意位置上，这就包括了：类中、方法中、代码块中。不过如果从实用的角度来讲，在方法中定义内部类的形式是最多的。
    内部类特点：破坏了程序的结构；方便进行私有属性的访问；以后如果在类名称上发现了“."，应该立刻想到是内部类的概念。
=========================================================================
继承的定义与使用：
=========================================================================
    面向对象的第二大特点就是继承：而继承的主要作用在于，在已有基础上继续进行功能上的扩充。
-------------------------------------------------------------------------
继承的实现：
    在java中使用extends关键子来进行实现，其定义的语法如下：
	继承关系：class子类extends父类；
	    |- 子类在一些书上也也被称为派生类；
	    |- 父类也被称为超类（Super Class）。
    当发生了类继承关系之后，自类可以直接继承父类的操作，也就是说可以实现代码的重用。并且子类最低也维持和父类相同的功能。当然子类也可以进行功能上的扩充，例如：扩充属性和方法。
-------------------------------------------------------------------------
继承的限制：
    虽然从本质上来讲继承子类可以对父类操作惊喜共享，但是从另外一个角度来说，继承本身也是存在有一些限制的。
1、子类对象在进行实例化前一定会首先实例化父类对象，默认调用弗雷的构造方法后，再调用子类的构造进行子类对象实例化； 
    在子类的构造方法之中，相当于隐含了一个语句“super()"。
    但如果此时父类里没有提供无参构造方法，那么这个时候就必须使用super（）明确的指明你要调用的父类构造方法。
2、java中只允许单继承，不允许多继承；
    一个子类只能继承一个父类
总结：java不允许多重继承，但是允许多层继承。
3、在进行继承的时候，子类会继承父类的所有结构，这个时候需要注意的是，所有的非私有操作属于显示继承（可以直接调用），而所有私有操作属于隐式继承（通过其他形式调用，例如：setter、getter）。
    子类能够使用的是所有的非private操作（public），而所有的private操作肯定无法直接使用，所有称为隐式继承。
-------------------------------------------------------------------------
总结：
	1、继承的语法以及继承的目的（扩展已有类的功能，使代码重用）；
	2、子类对象的实例化流程，不管如何操作一定要先实例化父类对象，而后再实例化子类对象；
	3、继承的限制：不允许多重继承，只允许多层继承
=========================================================================
覆写：
=========================================================================
    此时有可能出现这样一种情况，如果子类现在定义了与父类相同的方法或者是属性的时候，这样的操作就称为覆写。
-------------------------------------------------------------------------
方法的覆写：（重点）：
    所谓的方法的覆写指的是子类定义了与父类方法名称，参数类型及个数完全相同的方法。但是被覆写的方法不能够拥有比父类更为严格的访问控制权限。
    在以后进行覆写方法使用的时候一定关注以下两点：
	你当前使用的对象是通过哪个类new的；
	当调用某一个方法，如果该方法已经被子类所覆写了，则调用的一定是被覆写过的方法；
    方法覆写的时候也有一个明确的要求：被覆写的方法不能够拥有比父类更为严格的访问控制权限。关于访问控制才是封装的全部内容，三种访问控制权限：private<default<public；（defaylt：不写private或public）
    那么也就意味着如果说现在父类中的方法使用了public进行定义，那么子类中使用的权限只能够是public，而如果父类的方法使用的是default权限，那么子类可以使用default或者是public。 
结论：以后写方法就写public，至少能保证基本上的正确，同时以后只要写属性，98%的情况下都写private。
-------------------------------------------------------------------------
重载和覆写的区别：
No	区别	重载				覆写
1	英文单词	OverLoading			Override
2	概念	方法名称相同，参数的类型及个数不同	方法名称、返回值类型、参数的类型及个数完全相同
3	范围	发生在一个类之中			继承关系之中
4	限制	没有权限要求			被覆写的方法不能拥有比父类更为严格的访问控制权限

方法重载的时候返回值可以不同，但是良好的设计上要求返回类型一致。
-------------------------------------------------------------------------
属性覆盖：（了解）
    当子类定义了和父类属性名称完全相同的属性的时候，就称为属性覆盖。
    本身是没有任何意义的，其核心的原因在于：所有类中的属性都要求使用private封装，那么一旦封装了，子类一定不知道父类有哪些属性，所以覆盖属性也就没有任何的意义。
结论：在定义的时候没事不用重名。
-------------------------------------------------------------------------
super关键字：
    在子类对象实例化操作的时候，子类调用父类构造方法的时候使用；在进 选覆写的操作过程之中，子类也可以使用super.方法()、super.属性 明确的调用父类中的方法或属性。
    如果此时直接写上了“this.本类"操作，按摩就表示先从本类查找所需要的方法，如果本类没有，则去找父类中指定的方法进行调用。而如果是"super.本类“表示的是不查找本类而直接调用父类中的方法。 
    可以发现super和this使用形式上非常的相似，但是两者最大的区别是super是子类访问父类的操作，而this是本类的访问处理操作
-------------------------------------------------------------------------
this和super的区别：
No	区别	this				super
1	概念	访问被类中的属性、方法		由子类访问父类中的属性或方法
2	查找范围	先查找本类，如果本类没有则调用父类	不查找本类而直接调用父类定义
3	特殊	表示当前对象			无

    能使用super.方法()一定要明确的标记出是父类的操作。

1、子类覆写父类的方法是因为父类的方法功能不足，才需要覆写；
2、方法覆写的时候使用的就是public权限，将父类的方法名称直接粘贴过来。
=========================================================================
现在要求定义一个数组（整形数据）的操作类，在这个类中有如下几个要求：
	该数组的大小与类创建对象的时候动态决定；
	可以通过类向数组中进行数据的保存，保存的时候需要考虑到数组的大小问题；
	可以取得数组的全部数据。
	如果发现数组空间不足，则可以进行数组长度的动态扩充；

而后在这
=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------


