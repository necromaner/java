
=========================================================================
构造方法和普通方法在定义上有区别：
首先构造方法没有返回值，并且名字要与类名保持一致。
构造方法可以用来完成,成员属性的初始化工作。
每个类至少有一个构造方法，如果没有，系统会提供一个默认的无参构造.
而普通方法，就是类的行为举止。表明该做什么事情..等等。
=========================================================================
String:
=========================================================================
    直接赋值（=“hello”），只会开辟一块堆内存空间，并且该字符串对象可以保存在对象池中以供下次使用（每个赋值内容一样的数组，指向内存地址相同，减少内存重复开辟，节约内存）
    构造方法（new String("hello")）,会开辟两块堆内存空间， 其中一块堆内存空间将成为垃圾空间，并且不会保存在对象池中（可以使用.intern()方式手工入池（（new String("hello")。intern（）），除了这一缺点以外，实际上也会对字符串共享产生问题
所以直接赋值比构造方法好
-------------------------------------------------------------------------
    “==”	:进行的是数值比较，比较的是两个字符串内存地址数值
    “equal()"：	可以进行字符串内容的比较
最好字符串放在前面，如："hello".equal(input),防止没有输入内容造成错误

    字符串不适合频繁修改，如String x="hello "; x+="word";就产生三个内存空间“hello "、"word"、"hello word"，其中前两个为垃圾内存空间
-------------------------------------------------------------------------
总结：
    1.字符串的使用就采用直接赋值的模式完成。
    2.字符串的比较就使用equals（）方法实现
    3.字符串没事别改变太多
-------------------------------------------------------------------------
字符串与字符数组转换：
public String(char[] value)	将字节数组中的所有内容变为字符串
public String(char[] value, int offset, int count)	将字节数组中的部分内容变为字符串 offset：开始位置 count：个数
public char charAt(int index)	指定索引位置的字符，索引从0开始
public char[] toCharArray()	将字符串变为字符数组
-------------------------------------------------------------------------
字符串与字节 转换：
public String(byte[] value)	将字符数组中的所有内容变为字符串
public String(byte[] value, int offset, int length)	将字符数组中的部分内容变为字符串 offset：开始位置 count：个数
public byte[] getBytes()	将字符串以字节数组的形式返回
-------------------------------------------------------------------------
字符串比较：
public boolean equal(String anObject)	区分大小写比较
public boolean equalIgnoreCase(String anotherString)	不区分大小写比较
public int compareTo(String anotherString)	比较两个字符串大小关系，相等返回0，大于返回内容大于0，小于返回内容小于0，能比较中文
-------------------------------------------------------------------------
字符串查找：
public boolean contains(String s)	判断一个子字符串是否存在
public int indexOf(String str)	从头开始查找指定字符串的位置，查到了返回位置的开始索引，如果查不到返回-1
public int indexOf(String str, int fromIndex)	从指定位置开始查找子字符串的位置
public int lastIndexOf(String str)	由后向前查找子字符串的位置
public int lastIndexOf(String str, int fromIndex)	从指定位置开始由后向前查找子字符串的位置
public boolean startsWith(String prefix)	从头开始判断是否以指定的字符串开头
public boolean startsWith(String prefix, int toffset)	从指定位置开始判断是否以指定的字符串开头
public boolean endsWith(String suffix)	判断是否以指定的子字符串结尾

最方便的是contains（），直接返回boolean类型。该判断形势是从jdk1.5开始的。
-------------------------------------------------------------------------
字符串替换：
public String replaceAll(String regex, String replacement)	替换所有指定内容 regex：要替换的字符串，replacement：替换为的字符串
public String replaceFirst(String regex, String replacement)	替换首个内容
-------------------------------------------------------------------------
字符串拆分：
public String[] split(String regex)	将字符串全部拆分 regex：以该字符串作为分割符拆分
public String[] split(String regex，int limit)	将字符串部分拆分，该数组长度就是limit极限 limit：拆分为最多的指定个数的 字符串，前面拆，后面就不拆了

如果发现有些内容无法拆分开，就需要使用"\\"转译，如ip地址（.split("\\.");)
-------------------------------------------------------------------------
字符串截取：
public String substring(int beginIndex)	从指定索引截取到结尾
public String substring(int beginIndex,int endIndex)	截取部分内容
-------------------------------------------------------------------------
其他操作：
public String trim()	去掉字符串中左右空格，保留中间空格
public String toUpperCase()	字符串转大写
public String toLowerCase()	字符串转小写
    使用这两个不是字母的不转换
public String intern()	字符串入对象池
public String concat(String str)	字符串连接，等同于“+”
public int length()	取得字符串的长度
public boolean isEmpty()	判断是否为空字符串（但不是null，而是长度为0）没有内容为true

首字母大写在程序开发中使用频率很高
public static String initcap(String str){
    if (str==null&&"".equals(str)){
         return str;
    }
    if (str.length()>1){
         return str.substring(0,1).toUpperCase()+str.substring(1);
    }
    return str.toUpperCase();
}
=========================================================================
this：
=========================================================================
this从实际讲可以做三件事：调用本类属性、调用本类方法（普通、构造）、表示当前对象（相对概念）。

只要在类的方法中访问类的属性，那么属性前一定要加this关键字形式

类中的方法一共有两种：
	普通方法：this.方法名称（参数...）;
	构造方法：this(参数...)。
    虽然调用本类的普通方法前可以不使用this，但是强烈建议追加上this，这样的目的是可以区分方法的定义来源。
构造方法与普通方法最大的区别：使用关键字new实例化类新对象的时候使用一次，而普通方法是在对象实例化完成后（构造方法已经执行过了）可以调用多次。
    在java里面支持类构造方法的互相调用。
this（） 调用本类无参构造

虽然使用this可以实现构造方法的互相调用，但是此时有一下两点要求：
	this（）调用构造方法的语句必须放在构造方法的首行；
	使用this调用构造方法的时候请留有出口；

只要有某一个对象调用了本类中的方法，那么这个this就表示当前执行的对象。
=========================================================================
引用传递：
=========================================================================
引用传递是java的整体核心，如果不懂引用传递，基本上所有的代码都无法进行正常点分析。
-------------------------------------------------------------------------
以后开发过程中，所使用到的类基本都要求由开发者自己来定义。这些里面都使用的引用传递的概念
-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------


