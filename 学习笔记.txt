
=========================================================================
构造方法和普通方法在定义上有区别：
首先构造方法没有返回值，并且名字要与类名保持一致。
构造方法可以用来完成,成员属性的初始化工作。
每个类至少有一个构造方法，如果没有，系统会提供一个默认的无参构造.
而普通方法，就是类的行为举止。表明该做什么事情..等等。
=========================================================================
String:
=========================================================================
    直接赋值（=“hello”），只会开辟一块堆内存空间，并且该字符串对象可以保存在对象池中以供下次使用（每个赋值内容一样的数组，指向内存地址相同，减少内存重复开辟，节约内存）
    构造方法（new String("hello")）,会开辟两块堆内存空间， 其中一块堆内存空间将成为垃圾空间，并且不会保存在对象池中（可以使用.intern()方式手工入池（（new String("hello")。intern（）），除了这一缺点以外，实际上也会对字符串共享产生问题
所以直接赋值比构造方法好
-------------------------------------------------------------------------
    “==”	:进行的是数值比较，比较的是两个字符串内存地址数值
    “equal()"：	可以进行字符串内容的比较
最好字符串放在前面，如："hello".equal(input),防止没有输入内容造成错误

    字符串不适合频繁修改，如String x="hello "; x+="word";就产生三个内存空间“hello "、"word"、"hello word"，其中前两个为垃圾内存空间
-------------------------------------------------------------------------
总结：
    1.字符串的使用就采用直接赋值的模式完成。
    2.字符串的比较就使用equals（）方法实现
    3.字符串没事别改变太多
-------------------------------------------------------------------------
字符串与字符数组转换：
public String(char[] value)	将字节数组中的所有内容变为字符串
public String(char[] value, int offset, int count)	将字节数组中的部分内容变为字符串 offset：开始位置 count：个数
public char charAt(int index)	指定索引位置的字符，索引从0开始
public char[] toCharArray()	将字符串变为字符数组
-------------------------------------------------------------------------
字符串与字节 转换：
public String(byte[] value)	将字符数组中的所有内容变为字符串
public String(byte[] value, int offset, int length)	将字符数组中的部分内容变为字符串 offset：开始位置 count：个数
public byte[] getBytes()	将字符串以字节数组的形式返回
-------------------------------------------------------------------------
字符串比较：
public boolean equal(String anObject)	区分大小写比较
public boolean equalIgnoreCase(String anotherString)	不区分大小写比较
public int compareTo(String anotherString)	比较两个字符串大小关系，相等返回0，大于返回内容大于0，小于返回内容小于0，能比较中文
-------------------------------------------------------------------------
字符串查找：
public boolean contains(String s)	判断一个子字符串是否存在
public int indexOf(String str)	从头开始查找指定字符串的位置，查到了返回位置的开始索引，如果查不到返回-1
public int indexOf(String str, int fromIndex)	从指定位置开始查找子字符串的位置
public int lastIndexOf(String str)	由后向前查找子字符串的位置
public int lastIndexOf(String str, int fromIndex)	从指定位置开始由后向前查找子字符串的位置
public boolean startsWith(String prefix)	从头开始判断是否以指定的字符串开头
public boolean startsWith(String prefix, int toffset)	从指定位置开始判断是否以指定的字符串开头
public boolean endsWith(String suffix)	判断是否以指定的子字符串结尾

最方便的是contains（），直接返回boolean类型。该判断形势是从jdk1.5开始的。
-------------------------------------------------------------------------
字符串替换：
public String replaceAll(String regex, String replacement)	替换所有指定内容 regex：要替换的字符串，replacement：替换为的字符串
public String replaceFirst(String regex, String replacement)	替换首个内容
-------------------------------------------------------------------------
字符串拆分：
public String[] split(String regex)	将字符串全部拆分 regex：以该字符串作为分割符拆分
public String[] split(String regex，int limit)	将字符串部分拆分，该数组长度就是limit极限 limit：拆分为最多的指定个数的 字符串，前面拆，后面就不拆了

如果发现有些内容无法拆分开，就需要使用"\\"转译，如ip地址（.split("\\.");)
-------------------------------------------------------------------------
字符串截取：
public String substring(int beginIndex)	从指定索引截取到结尾
public String substring(int beginIndex,int endIndex)	截取部分内容
-------------------------------------------------------------------------
其他操作：
public String trim()	去掉字符串中左右空格，保留中间空格
public String toUpperCase()	字符串转大写
public String toLowerCase()	字符串转小写
    使用这两个不是字母的不转换
public String intern()	字符串入对象池
public String concat(String str)	字符串连接，等同于“+”
public int length()	取得字符串的长度
public boolean isEmpty()	判断是否为空字符串（但不是null，而是长度为0）没有内容为true

首字母大写在程序开发中使用频率很高
public static String initcap(String str){
    if (str==null&&"".equals(str)){
         return str;
    }
    if (str.length()>1){
         return str.substring(0,1).toUpperCase()+str.substring(1);
    }
    return str.toUpperCase();
}
=========================================================================
this：
=========================================================================
this从实际讲可以做三件事：调用本类属性、调用本类方法（普通、构造）、表示当前对象（相对概念）。

只要在类的方法中访问类的属性，那么属性前一定要加this关键字形式

类中的方法一共有两种：
	普通方法：this.方法名称（参数...）;
	构造方法：this(参数...)。
    虽然调用本类的普通方法前可以不使用this，但是强烈建议追加上this，这样的目的是可以区分方法的定义来源。
构造方法与普通方法最大的区别：使用关键字new实例化类新对象的时候使用一次，而普通方法是在对象实例化完成后（构造方法已经执行过了）可以调用多次。
    在java里面支持类构造方法的互相调用。
this（） 调用本类无参构造

虽然使用this可以实现构造方法的互相调用，但是此时有一下两点要求：
	this（）调用构造方法的语句必须放在构造方法的首行；
	使用this调用构造方法的时候请留有出口；

只要有某一个对象调用了本类中的方法，那么这个this就表示当前执行的对象。
=========================================================================
引用传递：
=========================================================================
引用传递是java的整体核心，如果不懂引用传递，基本上所有的代码都无法进行正常点分析。
-------------------------------------------------------------------------
以后开发过程中，所使用到的类基本都要求由开发者自己来定义。这些里面都使用的引用传递的概念】
=========================================================================
static:
=========================================================================
    在所有定义的方法上以及属性上实际上都可以使用static关键字进行定义。
-------------------------------------------------------------------------
static属性：
    访问static属性都使用类名称，所有的非static的属性必须在产生实例化对象之后才可以使用，而所有static的属性不受实例化对象的限制，也就是说是否有对象与static属性操作无关。
选择：关于static属性与非static属性定义的选择
    在定义类99%的情况下是不会考虑static属性的； 
    如果需要描述共享属性的概念，或者不希望受到实例化对象控制的使用static属性
-------------------------------------------------------------------------
static方法：
    Static定义的属性可以被类名称直接访问，那么同样如果使用static定义的方法也可以直接被类名称进行访问。同样不受到实例化对象的控制。
    现在类中已经存在有static方法和非static方法，那么这个时候对于两者的互相调用就存在有限制；
	所有的static方法不允许调用非static定义的属性或方法；调用使用类.对象
	所有的非static方法允许访问static方法或属性
	原因：因为所有的static方法可以在没有实例化对象的时候访问，而所有的非static操作必须在有实例化对象产生之后才可以操作。
	使用static的属性是影响目的（因为属性都需要封装），但是使用static的方法目的只有一个：某些方法不希望受到类的限制，即：可以在没有实例化对象的时候进行执行。
-------------------------------------------------------------------------
主方法组成：
    如果一个方法定义在主类之中类之中，并且由主方法直接调用，那么该方法的定义语法如下：
    public static 返回值类型 方法名称（参数列表）{}
	public:	表示的是公共的，主方法作为起点必须可以访问；
	static:执行Java程序的时候执行的是一个类名称，所以表示不受实例化对象限制；
	void:主方法是一切的起点；
	main:是一个系统定义好的方法名称；
	String args[]:表示该类执行时所需要的相关参数。
-------------------------------------------------------------------------
static应用：
    Static属性的最大功能是进行共享的操作，所以在这一基础上可以使用static做一个对象产生的计数统计。所有新对象的产生一定要使用构造方法完成，所以可以在构造方法实现统计。
1、static定义的属性和方法并不是你在进行类设计时的首要选择；
2、static的属性和方法不受到一个类的实例化对象限制，可以由类名称直接定义、
=========================================================================
代码块：（不重要）代码中加{}
=========================================================================
    代码块是一个不重要的概念，但是作为结构清楚一下就可以了。所谓的代码块指的是使用了"{}"定义的一段程序代码，而代码块根据其定义的位置以及声明的关键字不同一共可以分为四类：普通代码块、构造块、静态块、同步代码块。
-------------------------------------------------------------------------
普通代码块：（没用） 类中加{}
    普通代码块指的是定义在方法中的代码块。
    如果觉得限制的方法中代码写的过长，但是又需要避免变量重名问题，往往会使用普通代码块，一般人不会用。 
-------------------------------------------------------------------------
构造块：
    构造块指的是定义在类中的代码块
    每一次使用关键字new实例化对象的时候一定调用构造方法，但是有了构造块之后发现构造块会优先于构造方法先执行。
    唯一好处是进行一些简单的逻辑操作，但是又没什么用。
    构造块的使用只是一种补充手段，而这种手段恰恰有没有意义。
-------------------------------------------------------------------------
静态块：类中加static{}
    是使用static关键字定义的代码块。但是如果要想去考虑静态块必须分为两种情况：
	1.是在非主类中定义的静态块；
	2.在主类中定义的静态块。
    静态块优先于构造块执行，而且不管产生多少个实例化对象，静态块也只使用一次。静态块最为主要的作用就是为static属性初始化。
    静态块也可以定义在主类里面，那么此时的静态块将优先于主方法执行，一般而言没有意义。
-------------------------------------------------------------------------
	如果在一些属性使用前做处理就使用构造块或静态块完成。
=========================================================================
内部类的定义及使用：
=========================================================================
    对应内部类的定义使用暂时不作为我们首要的类设计原则
-------------------------------------------------------------------------
内部类的基本概念：
    所谓的内部类指的就是一个类的内部进行其它类结构嵌套的操作语法格式。一层层进行类的嵌套定义。
    虽然内部类破坏了程序的结构从整体上来讲是不好，但是从另外一个方面来讲，内部类也是有优点的，优点在于外部类的私有访问
-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

=========================================================================

=========================================================================

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------

-------------------------------------------------------------------------


